# Why FFTW-js is Fast: Deep Analysis

FFTW-js is FFTW compiled to WebAssembly via Emscripten, inheriting all of FFTW's sophisticated optimizations.

## 1. The genfft Codelet Generator

FFTW's codelets aren't just unrolled loops - they're generated by a compiler (`genfft`) that:

1. **DAG Representation**: Builds a directed acyclic graph of all operations
2. **Algebraic Simplification**: Applies constant folding, strength reduction, and algebraic identities
3. **Common Subexpression Elimination (CSE)**: Identifies and reuses repeated computations
4. **Network Transposition**: Transposes the computation graph, simplifies, transposes back - exposes additional common subexpressions invisible to standard CSE
5. **Optimal Scheduling**: Produces a topological sort optimized for register allocation using cache-oblivious theory

**Key insight**: Their codelets have ~10-20% fewer operations than naively unrolled code.

## 2. Operation Fusion (Twiddle-Butterfly Fusion)

**What we do**: Fused twiddle multiply with butterfly in a single loop iteration (already implemented)

```wat
(local.set $x1 (call $simd_cmul (local.get $x1) (local.get $w)))  ;; twiddle
(v128.store (local.get $o0) (f64x2.add (local.get $x0) (local.get $x1)))  ;; butterfly
(v128.store (local.get $o1) (f64x2.sub (local.get $x0) (local.get $x1)))
```

**Impact**: Eliminates N/2 memory round-trips per stage.

## 3. Automatic Real-FFT Specialization

FFTW's genfft **automatically derives** optimized real-FFT codelets from complex algorithms by exploiting conjugate symmetry:

- Avoids redundant computation of conjugate pairs
- Uses real-only arithmetic where possible
- Fuses the pack/unpack steps with the FFT computation

## 4. Cache-Oblivious Recursion vs Iterative Approach

**Stockham (iterative)**: Breadth-first - processes all butterflies at each stage before moving to the next

- Good for small FFTs that fit in cache
- Poor locality for large FFTs - data touched logâ‚‚(N) times

**FFTW's approach**: Can use depth-first recursion

- Process subtrees completely before moving on
- Better cache utilization for large FFTs
- Working set stays in cache longer

## 5. The Planner

FFTW's runtime planner measures and selects algorithms. Since fftw-js is pre-compiled, it uses fixed plans optimized for the compilation target.

## Performance Gap Summary

The **40% gap at N=4096** is explained by:

1. **Precision difference** (~2x): f32x4 vs f64x2 SIMD throughput
2. **Memory bandwidth** (~50%): 8 bytes vs 16 bytes per complex number
3. **FFTW's genfft codelets**: Better register scheduling, more CSE
