#!/usr/bin/env node
/**
 * DIT Codelet Generator for f32 Dual-Complex FFT
 *
 * Generates WAT code for DIT (Decimation in Time) FFT codelets that:
 * - Load input in bit-reversed order
 * - Output in natural order (compatible with RFFT post-processing)
 * - Use dual-complex f32x4 SIMD (2 complex numbers per v128)
 *
 * This version uses explicit simulation to track data flow correctly.
 *
 * Usage: node generate-dit-codelet.js <size>
 * Example: node generate-dit-codelet.js 32
 */

const N = parseInt(process.argv[2]);

if (!N || N < 8 || (N & (N - 1)) !== 0) {
  console.error("Usage: node generate-dit-codelet.js <size>");
  console.error("Size must be a power of 2 >= 8");
  process.exit(1);
}

const LOG2_N = Math.log2(N);
const NUM_REGS = N / 2;

function bitReverse(x, bits) {
  let result = 0;
  for (let i = 0; i < bits; i++) {
    result = (result << 1) | (x & 1);
    x >>= 1;
  }
  return result;
}

function twiddle(k, n) {
  const angle = (-2 * Math.PI * k) / n;
  return { re: Math.cos(angle), im: Math.sin(angle) };
}

function fmtFloat(x) {
  if (Math.abs(x) < 1e-10) return "0.0";
  if (Math.abs(x - 1) < 1e-10) return "1.0";
  if (Math.abs(x + 1) < 1e-10) return "-1.0";
  return x.toFixed(7);
}

function twiddleType(w) {
  const eps = 1e-10;
  if (Math.abs(w.re - 1) < eps && Math.abs(w.im) < eps) return "ONE";
  if (Math.abs(w.re) < eps && Math.abs(w.im + 1) < eps) return "NEG_J";
  if (Math.abs(w.re) < eps && Math.abs(w.im - 1) < eps) return "J";
  if (Math.abs(w.re + 1) < eps && Math.abs(w.im) < eps) return "NEG_ONE";
  return "GENERAL";
}

// Simulate DIT FFT to understand the data flow
// Returns array of stages, each stage is array of butterfly operations
function simulateDIT() {
  // Initialize: position i gets input[bitrev(i)]
  // But we track by "working position" which starts as 0..N-1

  const stages = [];

  for (let stage = 0; stage < LOG2_N; stage++) {
    const span = 1 << stage;
    const halfSpan = span;
    const groupSize = 2 * span;
    const numGroups = N / groupSize;
    const twiddleN = groupSize;

    const butterflies = [];

    for (let g = 0; g < numGroups; g++) {
      for (let k = 0; k < halfSpan; k++) {
        const posA = g * groupSize + k;
        const posB = posA + halfSpan;
        const tw = twiddle(k, twiddleN);
        butterflies.push({ posA, posB, tw, twType: twiddleType(tw), k, twiddleN });
      }
    }

    stages.push(butterflies);
  }

  return stages;
}

function generateCodelet() {
  const lines = [];
  const indent = "    ";
  const stages = simulateDIT();

  lines.push(`  ;; ============================================================================`);
  lines.push(`  ;; N=${N} DIT Dual-Complex Kernel (natural order output) - GENERATED`);
  lines.push(`  ;; ============================================================================`);
  lines.push(`  ;; ${N} complex numbers = ${NUM_REGS} dual-packed v128 values`);
  lines.push(`  ;; Generated by: node tools/generate-dit-codelet.js ${N}`);
  lines.push(``);
  lines.push(`  (func $fft_${N}_dit`);

  // Locals - use arrays for easier tracking
  const numRegSets = Math.min(LOG2_N, 4);
  const regSets = ["d", "t", "u", "v"].slice(0, numRegSets);

  for (const prefix of regSets) {
    const decls = [];
    for (let i = 0; i < NUM_REGS; i++) {
      decls.push(`(local $${prefix}${i} v128)`);
    }
    lines.push(`${indent}${decls.join(" ")}`);
  }
  lines.push(`${indent}(local $tmp v128) (local $tmp2 v128) (local $a v128) (local $b v128)`);
  lines.push(``);

  // Load in bit-reversed order
  lines.push(`${indent};; ============ Load in bit-reversed order ============`);
  for (let reg = 0; reg < NUM_REGS; reg++) {
    const pos0 = reg * 2;
    const pos1 = reg * 2 + 1;
    const idx0 = bitReverse(pos0, LOG2_N);
    const idx1 = bitReverse(pos1, LOG2_N);
    lines.push(
      `${indent}(local.set $d${reg} (v128.load64_lane 1 (i32.const ${idx1 * 8}) (v128.load64_zero (i32.const ${idx0 * 8}))))`,
    );
  }
  lines.push(``);

  // Process stages
  let srcSet = "d";
  let dstSet = "t";

  for (let stageIdx = 0; stageIdx < stages.length; stageIdx++) {
    const stage = stages[stageIdx];
    const span = 1 << stageIdx;
    const twiddleN = 2 << stageIdx;

    lines.push(
      `${indent};; ============ Stage ${stageIdx + 1} (span ${span}): W_${twiddleN} twiddles ============`,
    );

    // Track which output registers we've written
    const outputRegs = new Set();

    // Group butterflies by their register needs
    // Each butterfly operates on positions (posA, posB)
    // In dual-complex, position p is in register p/2, slot p%2

    for (const bf of stage) {
      const regA = Math.floor(bf.posA / 2);
      const slotA = bf.posA % 2;
      const regB = Math.floor(bf.posB / 2);
      const slotB = bf.posB % 2;

      // Determine output register
      // After butterfly, posA gets sum, posB gets diff
      const outRegA = Math.floor(bf.posA / 2);
      const outSlotA = bf.posA % 2;
      const outRegB = Math.floor(bf.posB / 2);
      const outSlotB = bf.posB % 2;

      if (regA === regB) {
        // Within-register butterfly
        lines.push(
          `${indent};; Butterfly (${bf.posA},${bf.posB}): within-reg, W_${twiddleN}^${bf.k}=${bf.twType}`,
        );
        generateWithinRegButterfly(lines, indent, srcSet, dstSet, regA, outRegA, bf.tw, bf.twType);
        outputRegs.add(outRegA);
      } else if (slotA === 0 && slotB === 0) {
        // Both in low slots of different registers
        // Check if there's a paired butterfly for high slots
        const paired = stage.find(
          (b) =>
            Math.floor(b.posA / 2) === regA &&
            b.posA % 2 === 1 &&
            Math.floor(b.posB / 2) === regB &&
            b.posB % 2 === 1,
        );

        if (paired && !outputRegs.has(outRegA)) {
          lines.push(
            `${indent};; Butterflies (${bf.posA},${bf.posB}) and (${paired.posA},${paired.posB})`,
          );
          generateDualButterfly(
            lines,
            indent,
            srcSet,
            dstSet,
            regA,
            regB,
            outRegA,
            outRegB,
            bf.tw,
            bf.twType,
            paired.tw,
            paired.twType,
          );
          outputRegs.add(outRegA);
          outputRegs.add(outRegB);
        }
      }
      // High-slot only butterflies are handled by the dual case above
    }

    // Copy any registers that weren't involved in butterflies
    for (let r = 0; r < NUM_REGS; r++) {
      if (!outputRegs.has(r)) {
        lines.push(`${indent}(local.set $${dstSet}${r} (local.get $${srcSet}${r}))`);
      }
    }

    lines.push(``);

    // Swap register sets
    const tmp = srcSet;
    srcSet = dstSet;
    dstSet = regSets[(regSets.indexOf(dstSet) + 1) % regSets.length];
    if (dstSet === srcSet) {
      dstSet = regSets[(regSets.indexOf(dstSet) + 1) % regSets.length];
    }
  }

  // Store in natural order
  lines.push(`${indent};; ============ Store in natural order ============`);
  for (let r = 0; r < NUM_REGS; r++) {
    lines.push(`${indent}(v128.store (i32.const ${r * 16}) (local.get $${srcSet}${r}))`);
  }

  lines.push(`  )`);
  return lines.join("\n");
}

function generateWithinRegButterfly(lines, indent, srcSet, dstSet, srcReg, dstReg, tw, twType) {
  // reg = [a, b] -> [a + b*w, a - b*w]

  if (twType === "ONE") {
    // Simple: [a, b] -> [a+b, a-b]
    lines.push(
      `${indent}(local.set $tmp (i8x16.shuffle 8 9 10 11 12 13 14 15 0 1 2 3 4 5 6 7 (local.get $${srcSet}${srcReg}) (local.get $${srcSet}${srcReg})))`,
    );
    lines.push(
      `${indent}(local.set $${dstSet}${dstReg} (i8x16.shuffle 0 1 2 3 4 5 6 7 16 17 18 19 20 21 22 23`,
    );
    lines.push(`${indent}  (f32x4.add (local.get $${srcSet}${srcReg}) (local.get $tmp))`);
    lines.push(`${indent}  (f32x4.sub (local.get $${srcSet}${srcReg}) (local.get $tmp))))`);
  } else if (twType === "NEG_J") {
    // b*(-j) = [b.im, -b.re]
    lines.push(
      `${indent}(local.set $a (i8x16.shuffle 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 (local.get $${srcSet}${srcReg}) (local.get $${srcSet}${srcReg})))`,
    );
    lines.push(
      `${indent}(local.set $b (i8x16.shuffle 12 13 14 15 8 9 10 11 12 13 14 15 8 9 10 11 (local.get $${srcSet}${srcReg}) (local.get $${srcSet}${srcReg})))`,
    );
    lines.push(
      `${indent}(local.set $b (f32x4.mul (local.get $b) (v128.const f32x4 1.0 -1.0 1.0 -1.0)))`,
    );
    lines.push(
      `${indent}(local.set $${dstSet}${dstReg} (i8x16.shuffle 0 1 2 3 4 5 6 7 16 17 18 19 20 21 22 23`,
    );
    lines.push(`${indent}  (f32x4.add (local.get $a) (local.get $b))`);
    lines.push(`${indent}  (f32x4.sub (local.get $a) (local.get $b))))`);
  } else {
    // General twiddle
    // a stays as-is, b gets multiplied by tw
    // b*w = [b.re*w.re - b.im*w.im, b.re*w.im + b.im*w.re]
    lines.push(
      `${indent}(local.set $a (i8x16.shuffle 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 (local.get $${srcSet}${srcReg}) (local.get $${srcSet}${srcReg})))`,
    );
    lines.push(
      `${indent}(local.set $b (i8x16.shuffle 8 9 10 11 12 13 14 15 8 9 10 11 12 13 14 15 (local.get $${srcSet}${srcReg}) (local.get $${srcSet}${srcReg})))`,
    );
    lines.push(
      `${indent}(local.set $tmp (i8x16.shuffle 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 (local.get $b) (local.get $b)))`,
    );
    lines.push(`${indent}(local.set $b (f32x4.add`);
    lines.push(
      `${indent}  (f32x4.mul (local.get $b) (v128.const f32x4 ${fmtFloat(tw.re)} ${fmtFloat(tw.re)} ${fmtFloat(tw.re)} ${fmtFloat(tw.re)}))`,
    );
    lines.push(
      `${indent}  (f32x4.mul (local.get $tmp) (v128.const f32x4 ${fmtFloat(-tw.im)} ${fmtFloat(tw.im)} ${fmtFloat(-tw.im)} ${fmtFloat(tw.im)}))))`,
    );
    lines.push(
      `${indent}(local.set $${dstSet}${dstReg} (i8x16.shuffle 0 1 2 3 4 5 6 7 16 17 18 19 20 21 22 23`,
    );
    lines.push(`${indent}  (f32x4.add (local.get $a) (local.get $b))`);
    lines.push(`${indent}  (f32x4.sub (local.get $a) (local.get $b))))`);
  }
}

function generateDualButterfly(
  lines,
  indent,
  srcSet,
  dstSet,
  regA,
  regB,
  outRegA,
  outRegB,
  tw1,
  tw1Type,
  tw2,
  tw2Type,
) {
  // regA = [a0, a1], regB = [b0, b1]
  // Butterfly 1: (a0, b0) with tw1 -> outRegA.low, outRegB.low
  // Butterfly 2: (a1, b1) with tw2 -> outRegA.high, outRegB.high

  // Extract pairs
  lines.push(
    `${indent}(local.set $a (i8x16.shuffle 0 1 2 3 4 5 6 7 16 17 18 19 20 21 22 23 (local.get $${srcSet}${regA}) (local.get $${srcSet}${regB}))) ;; [a0, b0]`,
  );
  lines.push(
    `${indent}(local.set $b (i8x16.shuffle 8 9 10 11 12 13 14 15 24 25 26 27 28 29 30 31 (local.get $${srcSet}${regA}) (local.get $${srcSet}${regB}))) ;; [a1, b1]`,
  );

  // Apply twiddles to b elements (high half of each)
  applyTwiddleToDualHigh(lines, indent, "$a", tw1, tw1Type);
  applyTwiddleToDualHigh(lines, indent, "$b", tw2, tw2Type);

  // Butterfly: [a, b*w] -> [a+b*w, a-b*w]
  lines.push(
    `${indent}(local.set $tmp (i8x16.shuffle 8 9 10 11 12 13 14 15 0 1 2 3 4 5 6 7 (local.get $a) (local.get $a)))`,
  );
  lines.push(`${indent}(local.set $tmp2 (i8x16.shuffle 0 1 2 3 4 5 6 7 16 17 18 19 20 21 22 23`);
  lines.push(`${indent}  (f32x4.add (local.get $a) (local.get $tmp))`);
  lines.push(`${indent}  (f32x4.sub (local.get $a) (local.get $tmp)))) ;; [a0+b0*w1, a0-b0*w1]`);

  lines.push(
    `${indent}(local.set $tmp (i8x16.shuffle 8 9 10 11 12 13 14 15 0 1 2 3 4 5 6 7 (local.get $b) (local.get $b)))`,
  );
  lines.push(`${indent}(local.set $a (i8x16.shuffle 0 1 2 3 4 5 6 7 16 17 18 19 20 21 22 23`);
  lines.push(`${indent}  (f32x4.add (local.get $b) (local.get $tmp))`);
  lines.push(`${indent}  (f32x4.sub (local.get $b) (local.get $tmp)))) ;; [a1+b1*w2, a1-b1*w2]`);

  // Recombine: outRegA = [sum0, sum1], outRegB = [diff0, diff1]
  lines.push(
    `${indent}(local.set $${dstSet}${outRegA} (i8x16.shuffle 0 1 2 3 4 5 6 7 16 17 18 19 20 21 22 23 (local.get $tmp2) (local.get $a)))`,
  );
  lines.push(
    `${indent}(local.set $${dstSet}${outRegB} (i8x16.shuffle 8 9 10 11 12 13 14 15 24 25 26 27 28 29 30 31 (local.get $tmp2) (local.get $a)))`,
  );
}

function applyTwiddleToDualHigh(lines, indent, regVar, tw, twType) {
  // Apply twiddle to the high element (b element) of dual [a, b]
  if (twType === "ONE") {
    // No change needed
    return;
  } else if (twType === "NEG_J") {
    // b*(-j) = [b.im, -b.re]
    lines.push(
      `${indent}(local.set $tmp (i8x16.shuffle 0 1 2 3 4 5 6 7 12 13 14 15 8 9 10 11 (local.get ${regVar}) (local.get ${regVar})))`,
    );
    lines.push(
      `${indent}(local.set ${regVar} (f32x4.mul (local.get $tmp) (v128.const f32x4 1.0 1.0 1.0 -1.0)))`,
    );
  } else {
    // General: extract high, multiply, recombine
    lines.push(
      `${indent}(local.set $tmp (i8x16.shuffle 8 9 10 11 12 13 14 15 8 9 10 11 12 13 14 15 (local.get ${regVar}) (local.get ${regVar})))`,
    );
    lines.push(`${indent}(local.set $tmp (f32x4.add`);
    lines.push(
      `${indent}  (f32x4.mul (local.get $tmp) (v128.const f32x4 ${fmtFloat(tw.re)} ${fmtFloat(tw.re)} ${fmtFloat(tw.re)} ${fmtFloat(tw.re)}))`,
    );
    lines.push(
      `${indent}  (f32x4.mul (i8x16.shuffle 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 (local.get $tmp) (local.get $tmp)) (v128.const f32x4 ${fmtFloat(-tw.im)} ${fmtFloat(tw.im)} ${fmtFloat(-tw.im)} ${fmtFloat(tw.im)}))))`,
    );
    lines.push(
      `${indent}(local.set ${regVar} (i8x16.shuffle 0 1 2 3 4 5 6 7 24 25 26 27 28 29 30 31 (local.get ${regVar}) (local.get $tmp)))`,
    );
  }
}

console.log(generateCodelet());
